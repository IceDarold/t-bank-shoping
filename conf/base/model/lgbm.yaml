# ==============================================================================
# Полный файл конфигурации для LightGBM
# ==============================================================================
# Для получения самой последней и полной информации, обратитесь к официальной
# документации: https://lightgbm.readthedocs.io/en/latest/Parameters.html

# --- Указатель на Python-класс в нашем фреймворке ---
_target_: src.models.lgbm.LGBMModel

# --- Словарь с параметрами, передаваемый в конструктор класса ---
params:
  # ============================================================================
  # 1. Основные параметры задачи
  # ============================================================================
  
  # `objective`: определяет функцию потерь.
  # - Классификация: "binary", "multiclass".
  # - Регрессия: "regression", "regression_l1" (MAE), "regression_l2" (MSE), "quantile", "mape".
  objective: "binary"

  # `metric`: метрика(и) для оценки на валидации. Может быть списком.
  # - Классификация: "auc", "binary_logloss", "f1", "precision", "recall".
  # - Регрессия: "rmse", "mae", "mape", "rmsle", "r2".
  metric: "auc"

  # `boosting_type` (или `boosting`): тип алгоритма.
  # - "gbdt": классический градиентный бустинг (по умолчанию).
  # - "dart": gbdt с Dropout для борьбы с переобучением.
  # - "goss": Gradient-based One-Side Sampling. Быстрый, но может быть менее точным.
  # - "rf": RandomForest (случайный лес).
  boosting_type: "gbdt"

  # `n_estimators`: количество деревьев. Управляется из `train.py` через early stopping.
  n_estimators: 2000

  # `learning_rate`: коэффициент обучения. Ключевой гиперпараметр.
  learning_rate: 0.05
  
  # ============================================================================
  # 2. Параметры производительности и железа
  # ============================================================================
  
  # `n_jobs`: количество потоков для параллелизации. -1 использует все.
  n_jobs: -1
  
  # `device_type`: устройство для обучения.
  # 'cpu' или 'gpu'. Требует сборки LightGBM с поддержкой GPU.
  # device_type: 'cpu'
  # `gpu_platform_id`, `gpu_device_id`: для выбора конкретного GPU.

  # ============================================================================
  # 3. Параметры структуры дерева и контроля переобучения (регуляризация)
  # ============================================================================

  # `num_leaves`: максимальное количество листьев в одном дереве.
  # Ключевой параметр для контроля сложности. Должен быть < 2^max_depth.
  # Типичные значения: 20-100.
  num_leaves: 31

  # `max_depth`: максимальная глубина дерева. -1 означает без ограничений.
  # Помогает бороться с переобучением.
  max_depth: -1

  # `min_child_samples` (или `min_data_in_leaf`): минимальное количество объектов в листе.
  min_child_samples: 20

  # `min_child_weight`: минимальная сумма весов (hessian) в листе.
  min_child_weight: 0.001

  # `subsample` (или `bagging_fraction`): доля объектов, случайно выбираемых для каждого дерева.
  # Включает бэггинг.
  subsample: 0.8
  
  # `subsample_freq` (или `bagging_freq`): частота применения бэггинга. 1 - на каждой итерации.
  subsample_freq: 1

  # `colsample_bytree` (или `feature_fraction`): доля признаков, случайно выбираемых для каждого дерева.
  colsample_bytree: 0.8

  # `reg_alpha` (L1 регуляризация): коэффициент регуляризации.
  reg_alpha: 0.1
  
  # `reg_lambda` (L2 регуляризация): коэффициент регуляризации.
  reg_lambda: 0.1
  
  # ============================================================================
  # 4. Прочие параметры
  # ============================================================================
  
  # `random_state` (или `seed`): сид для воспроизводимости.
  random_state: ${globals.seed}

  # `is_unbalance` или `scale_pos_weight`: для работы с несбалансированными классами.
  # - `is_unbalance: true`: автоматически вычисляет веса (только для бинарной классификации).
  # - `scale_pos_weight`: можно задать вес для положительного класса вручную.
  # is_unbalance: false

  # `importance_type`: как считать важность признаков.
  # - "split": по количеству раз, когда признак использовался для разделения.
  # - "gain": по общему приросту качества, который дал признак.
  importance_type: "gain"